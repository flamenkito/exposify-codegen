import * as fs from 'fs';
import * as path from 'path';
import { ClientGenerator, GeneratorOptions, ParseResult, ServiceMetadata, TypeMetadata } from '../types';

export const FILE_HEADER = `/**
 * This file is auto-generated by exposify.
 * Do not edit manually.
 */

`;

export abstract class BaseGenerator implements ClientGenerator {
  abstract readonly name: ClientGenerator['name'];

  generate(result: ParseResult, options: GeneratorOptions): void {
    const { output } = options;

    // Create output directories
    const servicesDir = path.join(output, 'services');
    const modelsDir = path.join(output, 'models');

    fs.mkdirSync(servicesDir, { recursive: true });
    fs.mkdirSync(modelsDir, { recursive: true });

    // Generate client infrastructure
    this.generateClient(output, options);

    // Generate services
    const serviceNames: string[] = [];
    for (const service of result.services) {
      const fileName = this.toKebabCase(service.className) + '.service.ts';
      const filePath = path.join(servicesDir, fileName);
      const code = this.generateService(service);
      fs.writeFileSync(filePath, FILE_HEADER + code);
      serviceNames.push(service.className);
      console.log(`Generated: services/${fileName}`);
    }

    // Generate models
    const modelNames: string[] = [];
    for (const type of result.types) {
      const fileName = this.toKebabCase(type.name) + '.ts';
      const filePath = path.join(modelsDir, fileName);
      const code = this.generateModel(type, result.types);
      fs.writeFileSync(filePath, FILE_HEADER + code);
      modelNames.push(type.name);
      console.log(`Generated: models/${fileName}`);
    }

    // Generate indexes
    const modelsIndex = this.generateModelsIndex(result.types);
    fs.writeFileSync(path.join(modelsDir, 'index.ts'), FILE_HEADER + modelsIndex);
    console.log('Generated: models/index.ts');

    const servicesIndex = this.generateServicesIndex(result.services);
    fs.writeFileSync(path.join(servicesDir, 'index.ts'), FILE_HEADER + servicesIndex);
    console.log('Generated: services/index.ts');

    const mainIndex = this.generateMainIndex();
    fs.writeFileSync(path.join(output, 'index.ts'), FILE_HEADER + mainIndex);
    console.log('Generated: index.ts');

    console.log(`\nGeneration complete! Output: ${output}`);
  }

  protected abstract generateClient(output: string, options: GeneratorOptions): void;
  protected abstract generateService(service: ServiceMetadata): string;

  protected generateModel(type: TypeMetadata, allTypes: TypeMetadata[]): string {
    let code: string;

    if (type.kind === 'class') {
      code = this.classToInterface(type.sourceCode, type.name);
    } else {
      code = this.cleanImports(type.sourceCode);
    }

    const imports = this.findModelImports(code, type.name, allTypes);
    if (imports) {
      return imports + '\n' + code;
    }

    return code;
  }

  protected findModelImports(code: string, currentTypeName: string, allTypes: TypeMetadata[]): string {
    const referencedTypes: string[] = [];

    for (const t of allTypes) {
      if (t.name === currentTypeName) continue;

      const typePattern = new RegExp(`\\b${t.name}\\b(?:<|\\s|;|\\)|\\]|,)`, 'g');
      if (typePattern.test(code)) {
        referencedTypes.push(t.name);
      }
    }

    if (referencedTypes.length === 0) return '';

    return referencedTypes
      .map((t) => `import { ${t} } from './${this.toKebabCase(t)}';`)
      .join('\n');
  }

  protected classToInterface(code: string, name: string): string {
    const lines = code.split('\n');
    const result: string[] = [];
    let inClass = false;
    let braceCount = 0;

    for (const line of lines) {
      const trimmed = line.trim();

      if (trimmed.startsWith('@')) continue;

      if (trimmed.includes(`class ${name}`)) {
        result.push(`export interface ${name} {`);
        inClass = true;
        braceCount = 1;
        continue;
      }

      if (inClass) {
        braceCount += (line.match(/{/g) || []).length;
        braceCount -= (line.match(/}/g) || []).length;

        if (trimmed.includes('constructor') || (trimmed.includes('(') && !trimmed.includes(':'))) {
          continue;
        }

        if (trimmed && !trimmed.startsWith('//')) {
          const cleanedLine = line
            .replace(/\bprivate\s+/g, '')
            .replace(/\bpublic\s+/g, '')
            .replace(/\bprotected\s+/g, '');
          result.push(cleanedLine);
        }

        if (braceCount === 0) {
          inClass = false;
        }
      } else {
        result.push(line);
      }
    }

    return result.join('\n');
  }

  protected cleanImports(code: string): string {
    return code
      .replace(/import\s*{[^}]*}\s*from\s*['"]class-validator['"];?\n?/g, '')
      .replace(/import\s*{[^}]*}\s*from\s*['"]class-transformer['"];?\n?/g, '')
      .replace(/@\w+\([^)]*\)\n?/g, '');
  }

  protected generateModelsIndex(types: TypeMetadata[]): string {
    const exports = types
      .map((t) => `export * from './${this.toKebabCase(t.name)}';`)
      .join('\n');

    return exports || '// No models generated\n';
  }

  protected generateServicesIndex(services: ServiceMetadata[]): string {
    const exports = services
      .map((s) => `export * from './${this.toKebabCase(s.className)}.service';`)
      .join('\n');

    return exports || '// No services generated\n';
  }

  protected generateMainIndex(): string {
    return `export * from './json-rpc.client';
export * from './services';
export * from './models';
`;
  }

  protected collectServiceImports(service: ServiceMetadata): Set<string> {
    const types = new Set<string>();

    for (const method of service.methods) {
      for (const param of method.parameters) {
        this.extractTypeNames(param.type, types);
      }
      this.extractTypeNames(method.returnType, types);
    }

    const primitives = ['string', 'number', 'boolean', 'void', 'null', 'undefined', 'any', 'unknown'];
    return new Set(Array.from(types).filter((t) => !primitives.includes(t.toLowerCase())));
  }

  protected extractTypeNames(typeStr: string, types: Set<string>): void {
    const matches = typeStr.match(/[A-Z][a-zA-Z0-9]*/g);
    if (matches) {
      for (const match of matches) {
        if (!['Promise', 'Observable', 'Array'].includes(match)) {
          types.add(match);
        }
      }
    }
  }

  protected toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
      .toLowerCase();
  }
}
